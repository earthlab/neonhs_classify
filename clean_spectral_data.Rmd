---
title: "Clean spectral data"
author: "Victoria Scholl"
date: "5/25/2020 Earth Lab GRA"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
library(dplyr)
library(ggplot2)
library(stringr)
library(tidyr)
library(tidyverse)
library(kableExtra)
library(reshape2)
library(pbapply)
```

### Explore data

Read original spectra, extracted using NEON data, by mbjoseph: https://gist.github.com/mbjoseph/5c18781e508460e14f64193571b98b7d 

Columns: 

* **individualID** - unique identifier for each individual plant. Individuals can have multiple measurements over time.
* **date.x** - date of plant measurement/observation
* **uid.x** - unique identifier for the record
* **namedLocation** - name of measurement location in NEON database
* **api.utmZone, adjEasting, adjNorthing** - UTM zone and coordinates of mapped stem
* **plantStatus** - physical status of the individual
* **growthForm** - growth form classification (sapling, tree, number of boles, etc.)
* **stemDiameter, measurementHeight** - diameter of stem and height at which it was measured 
* **height** - plant height 
* **taxonID** - species code
* **scientificName** - scientific name, associated with taxonID, lowest taxonomic rank that can be determined.
* **taxonRank** - lowest level taxonomic rank that can be determined for the individual (genus, species, variety)
* **band_idx** - number of the spectral band (band1, band 2, ... band 426)
* **wavelength_nm** - band wavelength in units of nm
* **reflectance** - decimal reflectance [0,1] extracted from NEON NIS hyperspectral imagery collected during same year
* **mask** - TRUE/LFALSE to identify water absorption bands


```{r}
all_spectra <- read.csv(here::here("data","all_spectra.csv"))
```

Number of unique **individualID** & **uid.x** values: 

```{r, message=TRUE}
length(unique(all_spectra$individualID))

length(unique(all_spectra$uid.x))
```

Number of unique **scientificName** & **taxonID** values (these should match):

```{r}
length(unique(all_spectra$taxonID))

length(unique(all_spectra$scientificName))
```

How many taxonomic identifications are at the genus vs species level? (Using the NEON-provided taxon Rank data)

```{r}
species_count <- all_spectra %>% 
  dplyr::distinct(uid.x, .keep_all = TRUE) %>%
  dplyr::group_by(taxonRank) %>% 
  dplyr::tally() %>% 
  kableExtra::kable() %>%
  kableExtra::kable_styling(bootstrap_options = "striped", 
                            full_width = F, 
                            position = "left")

species_count
```


```{r}
# create new columns for genus and species (disregard variations within species) 
all_spectra <- all_spectra %>% 
  tidyr::separate(scientificName, into = c('genus', 'species'), sep = ' ', 
           extra = 'drop', remove = FALSE)

length(unique(all_spectra$genus))

length(unique(all_spectra$species))
```


### Visualize spectra 

Based on Max's Gist code: https://gist.github.com/mbjoseph/5c18781e508460e14f64193571b98b7d 

Plot all spectra; color the spectra based on genus/species taxonomic level. 

```{r, warning=FALSE, fig.height=16, fig.width=14}
all_spectra %>%
  ggplot(aes(wavelength_nm, ifelse(mask, NA, reflectance), group = uid.x,
             # color each facet plot based on taxonRank
             color = taxonRank)) +
  geom_path(alpha = .2) +
  labs(x = '\n Wavelength (nm)',
       y = 'Reflectance \n',
       color = "Taxon Rank") + 
  facet_wrap(~scientificName
             # wrap long scientific names
             ,labeller = label_wrap_gen(20)) + 
  scale_color_manual(values = c("#e6550d","#1c9099", "#a8ddb5")) + 
  theme_minimal() + 
  # Adjust the text size and rotation angle 
  theme(text = element_text(size=11),
        axis.text.x = element_text(angle=90, hjust=1),
        axis.title.y = element_text(size = 14),
        axis.title.x = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 14))
```


### Explore the bands

Look at the starting wavelength ("band1") for each reflectance spectrum: 

```{r}
# how many different starting wavelength values in the data set? 
count_min_wavelengths <- all_spectra %>%
  dplyr::filter(band_idx == "band1") %>% 
  dplyr::group_by(wavelength_nm) %>%
  dplyr::count(wavelength_nm)

kableExtra::kable(count_min_wavelengths) %>%
  kableExtra::kable_styling(bootstrap_options = "striped", 
                            full_width = F, 
                            position = "left")
```

Spectra have different starting wavelengths (i.e. 381, 383, 385nm...) and increase in increments of 5nm. Most of them start at 384nm. 

```{r}
# find individualIDs that start with each of these wavelength band1 values
all_spectra %>% 
  dplyr::filter(band_idx == "band1") %>% 
  dplyr::filter(wavelength_nm == 384) %>% 
  dplyr::select(individualID) %>% 
  head(n = 6)

# 381 --> "NEON.PLA.D19.DEJU.00376"
# 382 --> "NEON.PLA.D06.UKFS.03259"
# 384 --> "NEON.PLA.D05.STEI.01215"
```


```{r warning=FALSE, fig.width=12}
# plot all 3 spectra to see their starting/ending wavelengths
all_spectra %>% 
  dplyr::filter(individualID %in% c("NEON.PLA.D19.DEJU.00376", 
                                    "NEON.PLA.D06.UKFS.03259",
                                    "NEON.PLA.D05.STEI.01215")) %>%
  ggplot(aes(x = wavelength_nm, y = reflectance, group = individualID)) +
  geom_line(aes(color = individualID), 
            alpha = 0.4) +
  labs(title = "Three reflectance spectra, each with different starting wavelength") + 
  theme_bw()
```



Beginning of wavelength range: 

```{r warning=FALSE, fig.width=12}
# plot all 3 spectra to see their starting wavelengths
all_spectra %>% 
  dplyr::filter(individualID %in% c("NEON.PLA.D19.DEJU.00376", 
                                    "NEON.PLA.D06.UKFS.03259",
                                    "NEON.PLA.D05.STEI.01215")) %>%
  ggplot(aes(x = wavelength_nm, y = reflectance, group = individualID)) +
  geom_line(aes(color = individualID), 
            alpha = 0.5, size = 1) +
  labs(title = "Three spectra, each with different wavelengths. Zoom in on beginning of spectra") + 
  # zoom in on beginning of spectra
  lims(x = c(380,400), y = c(0,0.5)) +
  theme_bw()
```

End of wavelength range: 

```{r warning=FALSE, fig.width=12}
# plot all 3 spectra to see their ending wavelengths
all_spectra %>% 
  dplyr::filter(individualID %in% c("NEON.PLA.D19.DEJU.00376", 
                                    "NEON.PLA.D06.UKFS.03259",
                                    "NEON.PLA.D05.STEI.01215")) %>%
  ggplot(aes(x = wavelength_nm, y = reflectance, group = individualID)) +
  geom_line(aes(color = individualID), 
            alpha = 0.5, size = 1) +
  labs(title = "Three spectra, each with different wavelengths. Zoom in on end of spectra") + 
  # zoom in on end of spectra
  lims(x = c(2495,2515), y = c(0, 0.3)) + 
  theme_bw()
```


### Standardize the bands: Interpolate wavelengths 

Interpolate wavelength values to have the same 426 bands starting at 384 nm, ending at 2512 nm, incrementing by 5 nm. To avoid data gaps on the ends, let's use a larger range. 

```{r, warning=FALSE}
# define the target wavelengths.
# use a larger range to get data on the ends.
# with a 5nm spacing, add 10nm to each end, and 4 to the total number of wavelengths. 
min_wl <- 384 
max_wl <- 2512 
num_wl <- 426
wavelength_vals <- seq(min_wl - 10, max_wl + 10,
                       length.out = num_wl + 4)

# interpolate all spectra efficiently 
interp_wl <- all_spectra %>%
  split(.$uid.x) %>%
  pblapply(function(df) {
    interpolated_reflectance <- approx(x= df$wavelength_nm, 
                                       y = df$reflectance, 
                                       xout = wavelength_vals)
    tibble(uid.x = unique(df$uid.x), 
           band_idx = seq_along(wavelength_vals), 
           wavelength_nm = as.integer(interpolated_reflectance$x), 
           reflectance = interpolated_reflectance$y)
  }) %>%
  bind_rows %>% 
  # remove rows with wavelength values outside the range of interest 
  dplyr::filter(wavelength_nm >= min_wl) %>% 
  dplyr::filter(wavelength_nm <= max_wl) %>% 
  # update the bank_idx column to be band1, ... band426
  dplyr::group_by(uid.x) %>% 
  dplyr::arrange(wavelength_nm) %>%
  dplyr::mutate(band_idx = paste0("band", 1:n())) %>%
  dplyr::arrange(uid.x)

# should be 426 unique wavelength values
length(unique(interp_wl$wavelength_nm))
```

Now, each spectrum (designated by a unique uid.x value) has the same 426 wavelength values. 
Merge the interpolated wavelengths and reflectance values into a copy of the data frame. 

```{r}
# make a copy of the original spectra 
cleaned_spectra <- all_spectra %>% 
  dplyr::select(-c(wavelength_nm, reflectance)) %>% 
  # merge in the interpolated wavelengths, based on uid.x and band_idx
  dplyr::left_join(interp_wl)
```


```{r, fig.width=12}
# plot all 3 interpolated spectra to see their starting wavelengths
interp_wl %>% 
  dplyr::filter(uid.x %in% c("0025a563-20b6-457c-9bc3-73f44c0c976c", 
                             "0038ba14-553e-42bb-945f-395df5fdbdad",
                             "050a6496-1037-461d-9289-82efa4feb17e")) %>% 
  ggplot(aes(x = wavelength_nm, y = reflectance, group = uid.x)) +
  geom_line(aes(color = uid.x), 
            alpha = 0.5, size = 1) +
  labs(title = "Three spectra, interpolated wavelengths! Zoom in on beginning of spectra") + 
  # zoom in on beginning of spectra
  lims(x = c(380,400), y = c(0,0.1)) +
  theme_bw()
```

### Standardize train, evaluation, & test set

How many samples per species? 

```{r fig.height=12}
thresh = 1

# count number of samples (unique uid.x values) per species 
taxonCounts <- cleaned_spectra %>% 
    distinct(uid.x, .keep_all = TRUE) %>% 
    group_by(taxonID) %>% 
    tally() %>% 
    # add a new column to indicate whether species count exceeds threshold
    mutate(countGT = case_when(
      n > thresh ~ TRUE,
      n <= thresh ~ FALSE
    ))

ggplot(taxonCounts, aes(y = reorder(taxonID, n), x = n)) + 
  geom_bar(stat = "identity", aes(fill = countGT)) + 
  labs(title = "Histogram of samples per species",
       fill = "count greater than threshold") + 
  theme_bw()
```


Split multiple observations of individuals across sets. Add a column to the data (“train”, “eval”, “test”). The 80/20 ratio (based on the [Pareto Principle](https://en.wikipedia.org/wiki/Pareto_principle)) for training/testing is common, where the 20% can be split into 10/10 for testing/validation. Andrew NG recommends 60/20/20 for training/testing/validation in his online machine learning course.   

```{r}
train_percent = 0.70
test_percent = 0.15
eval_percent = 0.15

# randomly sample all? 
# threshold to remove

```






### Output "clean dataset" 



